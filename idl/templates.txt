### TEMPLATE: API_FILE ###
import os, sys
import numpy as np
import ast
from collections import defaultdict

from .utils import *

TARGET_NAME = "{{API_NAME}}"

{{semantic_init}}

default_state = {
{{state}}
}

state = {
{{state}}
}

custom_functions = """
add_func_f32{
	%a = f32[] parameter(0)
	%b = f32[] parameter(1)
	ROOT %sum = f32[] add(%a, %b)
}
add_func_s32{
	%a = s32[] parameter(0)
	%b = s32[] parameter(1)
	ROOT %sum = s32[] add(%a, %b)
}
max_func_f32 {
  lhs = f32[] parameter(0)
  rhs = f32[] parameter(1)
  ROOT max = f32[] maximum(lhs, rhs)
}

max_func_s8 {
  lhs = s8[] parameter(0)
  rhs = s8[] parameter(1)
  ROOT max = s8[] maximum(lhs, rhs)
}

max_func_s32 {
  lhs = s32[] parameter(0)
  rhs = s32[] parameter(1)
  ROOT max = s32[] maximum(lhs, rhs)
}
"""

main_function_call = """
HloModule compiled\n""" + custom_functions + "\n"

global_counters = None
executable = None

mode = None
total_cost = 0
instruction_scopes = defaultdict(list)
instructions = []

constants = {}

loop_variables = ["main"]
conditional_clauses = []
cur_scope = "main"
scope_tuple_count = defaultdict(int)

instruction_store = []
compare_function = ""
call_statement = ""

def generate_full_hlotext(hbm_size: int):
	global instructions, main_function_call, compare_function, call_statement, global_counters, loop_variables, cur_scope, instruction_scopes
	counters, prologue = semantic_init(hbm_size)
	hlo_text = main_function_call + "\n"

	hlo_text += compare_function

	for scope, lines in reversed(list(instruction_scopes.items())):
		if(scope != "main"):
			for line in lines:
				hlo_text += "\t" + line + "\n"

	# Main call
	hlo_text += """\nENTRY %main """
	hlo_text += "{\n"
	for line in prologue:
		hlo_text += "\t" + line + "\n"
	for line in instruction_scopes["main"]:
		hlo_text += "\t" + line + "\n"
	hlo_text += f"\tROOT %hbm.res = s8[{hbm_size}] copy(%hbm.{global_counters['hbm']['counter']})\n"
	hlo_text+= "}\n"

	return hlo_text

def start_loop(var_name, start, end):
	global instructions, instruction_store, compare_function, call_statement, global_counters, loop_variables, cur_scope, instruction_scopes
	instruction_store = instructions
	var_name = "%" + var_name
	instructions = []
	counter_types = "s32[]"
	num_loop_counter = global_counters['total_loop_counter']
	scope_tuple_count[cur_scope] += 1

	for name, counter in global_counters.items():
		if isinstance(counter, dict):
			counter_types += ', ' + counter['type']
	for var in loop_variables[1:]:
		counter_types += ', s32[]'
	compare_function += f"""
%compare_function{global_counters['total_loop_counter']}(current_vals: ({counter_types})) -> pred[]{{
	%comp_tuple = ({counter_types}) parameter(0)
	%current_index = s32[] get-tuple-element(%comp_tuple), index=0
	%target = s32[] constant({end})
	ROOT %continue = pred[] compare(%current_index, %target), direction=LT
}}
 """
	tuple_num = scope_tuple_count[cur_scope]
	initial_tuple = f"%initial_index.{tuple_num}"
	num_counters = 0
	for name, counter in global_counters.items():
		if isinstance(counter, dict):
			initial_tuple += f", %{name}.{counter['counter']}"
			num_counters += 1
	for var in loop_variables[1:]:
		initial_tuple += f", {var}"
	
	call_statement = f"""
	%initial_index.{tuple_num} = s32[] constant({start})
	  %init_tuple.{tuple_num} = tuple({initial_tuple})
	%current_tuple.{tuple_num} = ({counter_types}) while(%init_tuple.{tuple_num}), body=%while_body{global_counters['total_loop_counter']}, condition=%compare_function{global_counters['total_loop_counter']}
 """
	instruction_scopes[cur_scope].append(call_statement)
	
	while_prologue = f"""
%while_body{global_counters['total_loop_counter']}(current_vals: ({counter_types})) -> ({counter_types}){'{'}
	%start_tuple = ({counter_types}) parameter(0)
	{var_name} = s32[] get-tuple-element(%start_tuple), index=0\n
 """
	cur_count = 1
	for var in loop_variables[1:]:
		while_prologue += f"\t{var} = s32[] get-tuple-element(%start_tuple), index={cur_count + num_counters}\n"
		cur_count += 1
	
	cur_ind = 1
	for name, counter in global_counters.items():
		if isinstance(counter, dict):
			while_prologue += f"\t%{name}.{counter['counter']} = {counter['type']} get-tuple-element(%start_tuple), index={cur_ind}\n"
			cur_ind += 1
	cur_scope = var_name
	instruction_scopes[cur_scope].append(while_prologue)
	loop_variables.append(var_name)
	global_counters['total_loop_counter'] += 1

def end_loop():
	global loop_variables, global_counters, instruction_scopes, cur_scope
	var_name = loop_variables[-1]
	instruction_scopes[cur_scope].append(f"%new_loop_index = s32[] add({var_name}, s32[] constant(1))")
	ret_val = f"ROOT %result = tuple(%new_loop_index"
	for name, counter in global_counters.items():
		if isinstance(counter, dict):
			ret_val += f", %{name}.{counter['counter']}"
	for var in loop_variables[1:-1]:
		ret_val += f", {var}"
	ret_val += ')\n}'
	instruction_scopes[cur_scope].append(ret_val)
	loop_variables.pop()
	cur_scope = loop_variables[-1]
	cur_ind = 1
	for name, counter in global_counters.items():
		if isinstance(counter, dict):
			counter['counter'] += 1
			instruction_scopes[cur_scope].append(f"%{name}.{counter['counter']} = {counter['type']} get-tuple-element(%current_tuple.{scope_tuple_count[cur_scope]}), index={cur_ind}")
			cur_ind += 1

def debug(prefix: str, data: str) -> None:
	global total_cost, instruction_scopes, cur_scope, constants, state, global_counters
	attrs = {}
	
	if mode == 'fsim-compile':
		lvars = {}
		output = []
		for name, arg in attrs.items():
			if(isinstance(arg, str)):
				hlo_lines, new_name = generate_loop_eq_vars(arg, global_counters)
				output.append(hlo_lines)
				attrs[name] = new_name
				global_counters['loop_var'] += 1

		prefix_bytes = np.frombuffer(prefix.encode('utf-8'), dtype=np.uint8)
		prefix_len = len(prefix_bytes)
		prefix_string = "{"
		for i in range(len(prefix_bytes)):
			if i != 0:
				prefix_string += ", "
			prefix_string += f"{prefix_bytes[i]}"
		prefix_string += "}"

		data_name = data.split("[")[0]

		rhs_loc = parameter_util(global_counters,  attrs, state, lvars, constants, data_name)
		data_dims = ast.literal_eval('[' + global_counters[data_name]["type"].split("[")[1].split("]")[0] + ']')
		debug_dims = ast.literal_eval('[' + data.split("[")[1].split("]")[0] + ']')
		slice_configs = []
		for i in range(len(debug_dims)):
			data_dims[i] = 1
		for i in range(len(data_dims)):
			data_dims[i] = str(data_dims[i])
			if i < len(debug_dims):
				slice_configs.append(str(debug_dims[i]))
			else:
				slice_configs.append('0')
		
		data_type = global_counters[data_name]["type"].split("[")[0]
		lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, 'debug_slice', data_type, data_dims)
		line = slice_load(lhs_loc, lhs_type, rhs_loc, slice_configs, attrs, state, lvars, constants)
		output.append(line)

		rhs_loc = parameter_util(global_counters,  attrs, state, lvars, constants, 'debug_slice')
		lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, 'debug_slice_f64', 'f64', data_dims)
		line = f'{lhs_loc} = {lhs_type} convert({rhs_loc})'
		output.append(line)

		rhs_loc = parameter_util(global_counters,  attrs, state, lvars, constants, 'debug_slice_f64')
		debug_prefix_loc = f'debug_prefix.{global_counters["instruction_counter"]}'
		output.append(f'{debug_prefix_loc} = u8[{prefix_len}] constant({prefix_string})')
		output.append(f'call.{global_counters["instruction_counter"]} = s32[] custom-call({debug_prefix_loc}, {rhs_loc}), custom_call_target="print_handler", custom_call_has_side_effect=true, api_version=API_VERSION_TYPED_FFI')
		instruction_scopes[cur_scope] += output
		global_counters['instruction_counter'] += 1

### TEMPLATE: API_FUNC ###
global total_cost, instruction_scopes, cur_scope, constants, state, global_counters
global_counters['loop_counter'] = 0
#comp_attrs = {
#{{set_comp_attr}}
#}
attrs = {
{{set_attributes}}
}
flag = 1
{{constraints}}
assert(flag) 
if mode == 'fsim':
	{{fsim}}
elif mode == 'fsim-compile':
	lvars = {}
	output = []
	for name, arg in attrs.items():
		if(isinstance(arg, str)):
			hlo_lines, new_name = generate_loop_eq_vars(arg, global_counters)
			output.append(hlo_lines)
			attrs[name] = new_name
			global_counters['loop_var'] += 1
{{update}}
{{fsim_compile}}
	instruction_scopes[cur_scope] += (output)
	global_counters['instruction_counter'] += 1
elif mode == 'cost':
	cost = {{cost}}
	total_cost += cost
else:
	attr_val = [{{attributes}}]
	attr_names = "{{attributes}}".split(',')
	attr_string = ""
	for i in range(len(attr_val) - 1):
		attr_string += f"{attr_names[i]} = {attr_val[i]}, "
	if(len(attr_val) >= 1):
		attr_string += f"{attr_names[len(attr_val) - 1]} = {attr_val[len(attr_val) - 1]}"
	print(f'{{func_name}}({attr_string})')

### TEMPLATE: NORM_LHS ###
lhs_loc = f'%{{lhs.var_name}}'
dim_sizes = {{lhs.array}}
dim_sizes = simplify_vals(dim_sizes, attrs, state, lvars)
dim_sizes = ','.join(dim_sizes)
lhs_type = f'{{lhs.var_type}}[{dim_sizes}]{{{lhs.num}}}'

### TEMPLATE: REGISTER_LHS ###
global_counters["{{lhs.var_orig}}"]["counter"] += 1
lhs_loc = f'%{{lhs.var_name}}'
lhs_type = f'{global_counters["{{lhs.var_orig}}"]["type"]}{{{lhs.num}}}'

### TEMPLATE: SLICE_LOAD ###
rhs_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{rhs_name}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
slice_configs = {{slice}}
line = slice_load(lhs_loc, lhs_type, rhs_loc, slice_configs, attrs, state, lvars, constants)
output.append(line)

### TEMPLATE: SLICE_STORE ###
rhs_update = parameter_util(global_counters,  attrs, state, lvars, constants, {{lhs}})
rhs_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{rhs_name}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{rhs_name}})
start_indices = {{slice}}
lines = slice_store(lhs_loc, lhs_type, rhs_loc, rhs_update, start_indices,
					attrs, state, lvars, constants, global_counters['start_counter'])
global_counters["start_counter"] += 1
output += lines

### TEMPLATE: RESHAPE ###
rhs_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{in}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
line = reshape_helper(lhs_loc, lhs_type, rhs_loc)
output.append(line)

### TEMPLATE: SIGN ###
rhs_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{in}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
line = f'{lhs_loc} = {lhs_type} sign({rhs_loc})'
output.append(line)

### TEMPLATE: CONVERT ###
rhs_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{in}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
line = convert_helper(lhs_loc, lhs_type, rhs_loc)
output.append(line)

### TEMPLATE: COPY ###
rhs_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{in}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
line = f'{lhs_loc} = {lhs_type} copy({rhs_loc})'
output.append(line)

### TEMPLATE: EXP ###
rhs_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{in}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
line = f'{lhs_loc} = {lhs_type} exponential({rhs_loc})'
output.append(line)

### TEMPLATE: TANH ###
rhs_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{in}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
line = f'{lhs_loc} = {lhs_type} tanh({rhs_loc})'
output.append(line)

### TEMPLATE: SQRT ###
rhs_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{in}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
line = f'{lhs_loc} = {lhs_type} sqrt({rhs_loc})'
output.append(line)

### TEMPLATE: RSQRT ###
rhs_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{in}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
line = f'{lhs_loc} = {lhs_type} rsqrt({rhs_loc})'
output.append(line)

### TEMPLATE: BITCAST_CONVERT ###
rhs_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{in}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
line = f'{lhs_loc} = {lhs_type} bitcast-convert({rhs_loc})'
output.append(line)

### TEMPLATE: DOT ###
a_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{A}})
b_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{B}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
line = dot_helper(lhs_loc, lhs_type, a_loc, b_loc,
				  {{lb}}, {{lc}}, {{rb}}, {{rc}})
output.append(line)

### TEMPLATE: TRANSPOSE ###
in_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{in}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
dims = "{{{dims}}}"
dims = dims.replace("'","")
line = f'{lhs_loc} = {lhs_type} transpose({in_loc}), dimensions={dims}'
output.append(line)

### TEMPLATE: SLICE ###
in_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{in}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
dims = "{{{dims}}}"
dims = dims[2:-2]
dims = dims.replace("[","")
dims = dims.replace("]","")
dims = dims.replace("`","")
dims = dims.split(",")
dims = non_dynamic_slice(dims, attrs, state, lvars, constants)
line = f'{lhs_loc} = {lhs_type} slice({in_loc}), {dims}'
output.append(line)

### TEMPLATE: CONCATENATE ###
in_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{in}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
dims = "{{{dims}}}"
dims = dims.replace("'","")
line = f'{lhs_loc} = {lhs_type} concatenate({in_loc}), dimensions={{0}}'
output.append(line)

### TEMPLATE: ADD ###
a_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{A}})
b_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{B}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
line = f'{lhs_loc} = {lhs_type} add({a_loc}, {b_loc})'
output.append(line)

### TEMPLATE: SUBTRACT ###
a_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{A}})
b_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{B}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
line = f'{lhs_loc} = {lhs_type} subtract({a_loc}, {b_loc})'
output.append(line)

### TEMPLATE: MULTIPLY ###
a_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{A}})
b_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{B}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
line = f'{lhs_loc} = {lhs_type} multiply({a_loc}, {b_loc})'
output.append(line)

### TEMPLATE: DIVIDE ###
a_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{A}})
b_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{B}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
line = f'{lhs_loc} = {lhs_type} divide({a_loc}, {b_loc})'
output.append(line)

### TEMPLATE: REDUCE ###
a_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{A}})
b_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{B}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
dim = {{dims}}
apply = {{to_apply}}
line = f'{lhs_loc} = {lhs_type} reduce({a_loc}, {b_loc}), dimensions={dim}, to_apply={apply}'
output.append(line)

### TEMPLATE: DYNAMIC_UPDATE_SLICE ###
a_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{A}})
b_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{B}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
dim = {{dims}}
line = f'{lhs_loc} = {lhs_type} dynamic-update-slice({a_loc}, {b_loc}, {dim})'
output.append(line)


### TEMPLATE: CONSTANT ###
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
simplify = simplify_vals([{{const}}], attrs, state, lvars, constants)
const= simplify[0]
line = f"{lhs_loc} = {lhs_type} constant({const})"
output.append(line)

### TEMPLATE: BROADCAST ###
b_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{A}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
dims = create_num_str({{size}})
#line = f"{lhs_loc} = {lhs_type} broadcast({b_loc}), dimensions={{}}"
line = f"{lhs_loc} = {lhs_type} broadcast({b_loc}), dimensions={dims}"
output.append(line)

### TEMPLATE: CLAMP ###
b_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{B}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
dims = create_num_str({{size}})
low = {{A}}
high = {{C}}
line = f"{lhs_loc} = {lhs_type} clamp(s32[] constant({low}), {b_loc}, s32[] constant({high}))"
output.append(line)

### TEMPLATE: BROADCAST_TYPE ###
b_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{A}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
dims = create_num_str({{size}})
line = f"{lhs_loc} = {lhs_type} broadcast({b_loc}), dimensions={{}}"
output.append(line)

### TEMPLATE: BROADCAST_DIM ###
b_loc = parameter_util(global_counters,  attrs, state, lvars, constants, {{A}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
dims = {{dims}}
line = f"{lhs_loc} = {lhs_type} broadcast({b_loc}), dimensions={dims}"
output.append(line)

### TEMPLATE: MAXIMUM ###
rhs_first = parameter_util(global_counters,  attrs, state, lvars, constants, {{A}})
rhs_second = parameter_util(global_counters,  attrs, state, lvars, constants, {{B}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
line = f'{lhs_loc} = {lhs_type} maximum({rhs_first}, {rhs_second})'
output.append(line)

### TEMPLATE: MINIMUM ###
rhs_first = parameter_util(global_counters,  attrs, state, lvars, constants, {{A}})
rhs_second = parameter_util(global_counters,  attrs, state, lvars, constants, {{B}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
line = f'{lhs_loc} = {lhs_type} minimum({rhs_first}, {rhs_second})'
output.append(line)

### TEMPLATE: SELECT_LT ###
rhs_first = parameter_util(global_counters,  attrs, state, lvars, constants, {{A}})
rhs_second = parameter_util(global_counters,  attrs, state, lvars, constants, {{B}})
rhs_choice1 = parameter_util(global_counters,  attrs, state, lvars, constants, {{C}})
rhs_choice2 = parameter_util(global_counters,  attrs, state, lvars, constants, {{D}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
comp_loc = f'comp.{global_counters["loop_counter"]}.{global_counters["instruction_counter"]}'
lhs_dim = get_dim({{size}}, attrs, state, lvars, constants)
line = f'{comp_loc} = pred{lhs_dim} compare({rhs_first}, {rhs_second}), direction=LT\n'
line += f'\t{lhs_loc} = {lhs_type} select({comp_loc}, {rhs_choice1}, {rhs_choice2})'
output.append(line)

### TEMPLATE: SELECT_EQ ###
rhs_first = parameter_util(global_counters,  attrs, state, lvars, constants, {{A}})
rhs_second = parameter_util(global_counters,  attrs, state, lvars, constants, {{B}})
rhs_choice1 = parameter_util(global_counters,  attrs, state, lvars, constants, {{C}})
rhs_choice2 = parameter_util(global_counters,  attrs, state, lvars, constants, {{D}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
comp_loc = f'comp.{global_counters["loop_counter"]}.{global_counters["instruction_counter"]}'
lhs_dim = get_dim({{size}}, attrs, state, lvars, constants)
line = f'{comp_loc} = pred{lhs_dim} compare({rhs_first}, {rhs_second}), direction=LT\n'
line += f'\t{lhs_loc} = {lhs_type} select({comp_loc}, {rhs_choice1}, {rhs_choice2})'
output.append(line)

### TEMPLATE: SELECT_EQ_VAR ###
rhs_first = {{A}}
rhs_second = {{B}}
rhs_choice1 = parameter_util(global_counters,  attrs, state, lvars, constants, {{C}})
rhs_choice2 = parameter_util(global_counters,  attrs, state, lvars, constants, {{D}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
comp_loc = f'comp.{global_counters["loop_counter"]}.{global_counters["instruction_counter"]}'
lhs_dim = get_dim({{size}}, attrs, state, lvars, constants)
line = f'%{comp_loc}.1 = pred[] compare(%{rhs_first}, s32[] constant(0)), direction=EQ\n'
line += f'%{comp_loc}.2 = pred[] compare(%{rhs_second}, s32[] constant(0)), direction=EQ\n'
line += f'%{comp_loc} = pred[] and(%{comp_loc}.1, %{comp_loc}.2)\n'
line += f'\t{lhs_loc} = {lhs_type} select(%{comp_loc}, {rhs_choice1}, {rhs_choice2})'
output.append(line)

### TEMPLATE: XOR ###
rhs_first = parameter_util(global_counters,  attrs, state, lvars, constants, {{A}})
rhs_second = parameter_util(global_counters,  attrs, state, lvars, constants, {{B}})
lhs_loc, lhs_type = lhs_util(attrs, state, global_counters, lvars, constants, {{lhs}}, {{type}}, {{size}})
line = f'{lhs_loc} = {lhs_type} xor({rhs_first}, {rhs_second})'
output.append(line)

### TEMPLATE: IF ###
simplify = simplify_vals(["{{config}}"], attrs, state, lvars, constants)
result = eval(simplify[0])
if(result):

### TEMPLATE: ELSE ###
else:

### TEMPLATE: REPEAT ###
loop_range = simplify_vals(["{{loop_range}}"], attrs, state, lvars, constants)
loop_range = int(loop_range[0])

for {{loop_var}} in range(loop_range):
tab lvars['{{loop_var}}'] = {{loop_var}}
tab global_counters["loop_counter"] += 1
### TEMPLATE: SEMANTIC_INIT ###
def semantic_init(hbm_size):
	global_counters = {
		'hbm': {
			'type': f's8[{hbm_size}]',
			'dim': '{0}',
			'counter': 0
		},
{{custom_counters}}
		'instruction_counter': 0,
		'start_counter': 0,
		'total_loop_counter': 0,
		'loop_counter': 0,
		'if_counter': 0,
		'loop_var': 0,
	}

	prologue = []
	prologue.append(f'%hbm.0 = s8[{hbm_size}]{{0}} parameter(0)')

{{custom_prologue}}
	return global_counters, prologue

### TEMPLATE: SEMANTIC_COUNTER ###
'{{var_name}}': {
	'type': '{{var_type}}{{var_dim}}',
	'dim': '{{var_num}}',
	'counter': 0
},
### TEMPLATE: PROLOGUE_INIT ###
	prologue.append(f'%{{var_name}}.0 = {{var_type}}{{var_dim}}{{{var_num}}} constant(0)')
### TEMPLATE: PROLOGUE_LINE ###
f'%{{var_name}}.0 = {{var_type}}{{var_dim}}{{{var_num}}} constant(0)',
